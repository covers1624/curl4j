diff --git a/ldso/dynlink.c b/ldso/dynlink.c
index ceca3c98..5ccb5e13 100644
--- a/ldso/dynlink.c
+++ b/ldso/dynlink.c
@@ -2108,6 +2108,7 @@ void *dlopen(const char *file, int mode)
 
 	if (!file) return head;
 
+    __libc_check_init();
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
 	pthread_rwlock_wrlock(&lock);
 	__inhibit_ptc();
diff --git a/src/env/__libc_start_lazy.c b/src/env/__libc_start_lazy.c
new file mode 100644
index 00000000..b6b4d81f
--- /dev/null
+++ b/src/env/__libc_start_lazy.c
@@ -0,0 +1,127 @@
+#include "libc.h"
+#include <fcntl.h>
+#include <string.h>
+#include <unistd.h>
+#include <elf.h>
+#include "syscall.h"
+#include "stdio_impl.h"
+
+#define AUX_CNT 38
+
+static void fclose_stack(FILE *f) {
+    syscall(SYS_close, f->fd);
+}
+
+// This is manual allocation of a FILE struct which is allocated on the stack.
+// We are not able to call regular fopen from this call path as it requires auxv to
+// be initialized.
+static void fopen_stack(const char *restrict filename, FILE *f, void *buf, int buf_size) {
+    // open the file
+    int fd = sys_open(filename, O_RDONLY, 0666);
+    if (!fd) return;
+
+    f->fd = fd;
+    f->buf = buf;
+    f->buf_size = buf_size;
+
+    f->lbf = EOF;
+
+    f->read = __stdio_read;
+    f->write = __stdio_write;
+    f->seek = __stdio_seek;
+    f->close = NULL;
+    f->lock = -1;
+}
+
+static void scan_envp(FILE *fd, void **env_start, void **env_end) {
+    char line[1025];
+    if (fgets(line, sizeof(line), fd) == NULL) {
+        return;
+    }
+
+    // Split on closed brace to get to the end of the proc name, may have spaces.
+    char *token = strtok(line, ")");
+    // Offset for above hack.
+    int tkOffset = 2;
+    int count = 1 + tkOffset;
+
+    // While we have tokens..
+    while (token != NULL) {
+        // Count 49 is env start.
+        if (count == 49) {
+            *env_start = (void *) strtoul(token, NULL, 10);
+        }
+        // Count 50 is env end.
+        if (count == 50) {
+            *env_end = (void *) strtoul(token, NULL, 10);
+            break;
+        }
+
+        token = strtok(NULL, " ");
+        count++;
+    }
+}
+
+static void doInit() {
+    FILE fd;
+    memset(&fd, 0, sizeof(FILE));
+
+    char buf[1024];
+    fopen_stack("/proc/self/stat", &fd, &buf, 1024);
+
+    if (!fd.fd) goto error;
+
+    void *env_start;
+    void *env_end;
+    scan_envp(&fd, &env_start, &env_end);
+    fclose_stack(&fd);
+
+    if (!env_start || !env_end)goto error;
+
+    // We have the address to the start of the env vars.
+    // However, we need the pointer _to_ the start of env vars within the pointers allocated for main.
+    // Which is stored above the env variable table. Just search up till we find it.
+    char **envp = env_start;
+    while (*envp != env_end) {
+        // This is because the pointer is not memory aligned. somehow.
+        if (sizeof(void *) == 4) {
+            envp = (char **) ((int) envp - 1);
+        } else {
+            envp = (char **) ((long) envp - 1);
+        }
+    }
+
+    // Similar to libc_start_main.c however, only initializes env and auxv.
+    __environ = envp;
+
+    size_t i;
+    for (i = 0; envp[i]; i++);
+
+    size_t *auxv;
+    libc.auxv = auxv = (void *) (envp + i + 1);
+
+    size_t aux[AUX_CNT] = {0};
+    for (i = 0; auxv[i]; i += 2) {
+        if (auxv[i] < AUX_CNT) {
+            aux[auxv[i]] = auxv[i + 1];
+        }
+    }
+    __hwcap = aux[AT_HWCAP];
+    if (aux[AT_SYSINFO]) {
+        __sysinfo = aux[AT_SYSINFO];
+    }
+    libc.page_size = aux[AT_PAGESZ];
+    __progname = __progname_full = "";
+
+    if (aux[AT_UID] != aux[AT_EUID] || aux[AT_GID] != aux[AT_EGID] || aux[AT_SECURE]) {
+        libc.secure = 1;
+    }
+
+    error:
+    libc.initialized = 1;
+}
+
+inline void __libc_check_init() {
+    if (libc.initialized) return;
+    doInit();
+}
diff --git a/src/env/__libc_start_main.c b/src/env/__libc_start_main.c
index c5b277bd..edc77da9 100644
--- a/src/env/__libc_start_main.c
+++ b/src/env/__libc_start_main.c
@@ -22,6 +22,9 @@ __attribute__((__noinline__))
 #endif
 void __init_libc(char **envp, char *pn)
 {
+    if (libc.initialized) return;
+    libc.initialized = 1;
+
 	size_t i, *auxv, aux[AUX_CNT] = { 0 };
 	__environ = envp;
 	for (i=0; envp[i]; i++);
diff --git a/src/internal/libc.h b/src/internal/libc.h
index 619bba86..ed678bb5 100644
--- a/src/internal/libc.h
+++ b/src/internal/libc.h
@@ -28,6 +28,7 @@ struct __libc {
 	size_t tls_size, tls_align, tls_cnt;
 	size_t page_size;
 	struct __locale_struct global_locale;
+    char initialized;
 };
 
 #ifndef PAGE_SIZE
@@ -37,6 +38,7 @@ struct __libc {
 extern hidden struct __libc __libc;
 #define libc __libc
 
+hidden void __libc_check_init();
 hidden void __init_libc(char **, char *);
 hidden void __init_tls(size_t *);
 hidden void __init_ssp(void *);
diff --git a/src/internal/vdso.c b/src/internal/vdso.c
index d46d3228..d832f32c 100644
--- a/src/internal/vdso.c
+++ b/src/internal/vdso.c
@@ -43,6 +43,7 @@ static int checkver(Verdef *def, int vsym, const char *vername, char *strings)
 void *__vdsosym(const char *vername, const char *name)
 {
 	size_t i;
+    __libc_check_init();
 	for (i=0; libc.auxv[i] != AT_SYSINFO_EHDR; i+=2)
 		if (!libc.auxv[i]) return 0;
 	if (!libc.auxv[i+1]) return 0;
diff --git a/src/ldso/dl_iterate_phdr.c b/src/ldso/dl_iterate_phdr.c
index 9546dd36..3b193fa3 100644
--- a/src/ldso/dl_iterate_phdr.c
+++ b/src/ldso/dl_iterate_phdr.c
@@ -16,6 +16,7 @@ static int static_dl_iterate_phdr(int(*callback)(struct dl_phdr_info *info, size
 	struct dl_phdr_info info;
 	size_t i, aux[AUX_CNT] = {0};
 
+    __libc_check_init();
 	for (i=0; libc.auxv[i]; i+=2)
 		if (libc.auxv[i]<AUX_CNT) aux[libc.auxv[i]] = libc.auxv[i+1];
 
diff --git a/src/locale/catopen.c b/src/locale/catopen.c
index 97f2446d..9b3181cc 100644
--- a/src/locale/catopen.c
+++ b/src/locale/catopen.c
@@ -34,6 +34,7 @@ nl_catd catopen(const char *name, int oflag)
 	char buf[PATH_MAX];
 	size_t i;
 	const char *path, *lang, *p, *z;
+    __libc_check_init();
 	if (libc.secure || !(path = getenv("NLSPATH"))) {
 		errno = ENOENT;
 		return (nl_catd)-1;
diff --git a/src/locale/duplocale.c b/src/locale/duplocale.c
index 5ce33ae6..5e0537e4 100644
--- a/src/locale/duplocale.c
+++ b/src/locale/duplocale.c
@@ -12,6 +12,7 @@ locale_t __duplocale(locale_t old)
 {
 	locale_t new = malloc(sizeof *new);
 	if (!new) return 0;
+    __libc_check_init();
 	if (old == LC_GLOBAL_LOCALE) old = &libc.global_locale;
 	*new = *old;
 	return new;
diff --git a/src/locale/locale_map.c b/src/locale/locale_map.c
index da61f7fc..1ece551f 100644
--- a/src/locale/locale_map.c
+++ b/src/locale/locale_map.c
@@ -63,6 +63,7 @@ const struct __locale_map *__get_locale(int cat, const char *val)
 	for (p=loc_head; p; p=p->next)
 		if (!strcmp(val, p->name)) return p;
 
+    __libc_check_init();
 	if (!libc.secure) path = getenv("MUSL_LOCPATH");
 	/* FIXME: add a default path? */
 
diff --git a/src/locale/setlocale.c b/src/locale/setlocale.c
index 360c4437..289c1d78 100644
--- a/src/locale/setlocale.c
+++ b/src/locale/setlocale.c
@@ -13,6 +13,7 @@ char *setlocale(int cat, const char *name)
 
 	if ((unsigned)cat > LC_ALL) return 0;
 
+    __libc_check_init();
 	LOCK(__locale_lock);
 
 	/* For LC_ALL, setlocale is required to return a string which
diff --git a/src/locale/uselocale.c b/src/locale/uselocale.c
index 0fc5ecbc..909bfb11 100644
--- a/src/locale/uselocale.c
+++ b/src/locale/uselocale.c
@@ -4,6 +4,7 @@
 
 locale_t __uselocale(locale_t new)
 {
+    __libc_check_init();
 	pthread_t self = __pthread_self();
 	locale_t old = self->locale;
 	locale_t global = &libc.global_locale;
diff --git a/src/malloc/lite_malloc.c b/src/malloc/lite_malloc.c
index 43a988fb..0dc607e1 100644
--- a/src/malloc/lite_malloc.c
+++ b/src/malloc/lite_malloc.c
@@ -21,6 +21,7 @@ static int traverses_stack_p(uintptr_t old, uintptr_t new)
 	const uintptr_t len = 8<<20;
 	uintptr_t a, b;
 
+    __libc_check_init();
 	b = (uintptr_t)libc.auxv;
 	a = b > len ? b-len : 0;
 	if (new>a && old<b) return 1;
diff --git a/src/malloc/mallocng/glue.h b/src/malloc/mallocng/glue.h
index 77f4c812..496cc938 100644
--- a/src/malloc/mallocng/glue.h
+++ b/src/malloc/mallocng/glue.h
@@ -43,6 +43,7 @@
 
 static inline uint64_t get_random_secret()
 {
+    __libc_check_init();
 	uint64_t secret = (uintptr_t)&secret * 1103515245;
 	for (size_t i=0; libc.auxv[i]; i+=2)
 		if (libc.auxv[i]==AT_RANDOM)
diff --git a/src/misc/getauxval.c b/src/misc/getauxval.c
index 57f21eed..9ae278b6 100644
--- a/src/misc/getauxval.c
+++ b/src/misc/getauxval.c
@@ -4,6 +4,7 @@
 
 unsigned long __getauxval(unsigned long item)
 {
+    __libc_check_init();
 	size_t *auxv = libc.auxv;
 	if (item == AT_SECURE) return libc.secure;
 	for (; *auxv; auxv+=2)
diff --git a/src/misc/issetugid.c b/src/misc/issetugid.c
index ddc2ca0e..a7cb4368 100644
--- a/src/misc/issetugid.c
+++ b/src/misc/issetugid.c
@@ -4,5 +4,6 @@
 
 int issetugid(void)
 {
+    __libc_check_init();
 	return libc.secure;
 }
diff --git a/src/signal/sigaction.c b/src/signal/sigaction.c
index e45308fa..f9c2dad9 100644
--- a/src/signal/sigaction.c
+++ b/src/signal/sigaction.c
@@ -19,6 +19,7 @@ volatile int __eintr_valid_flag;
 
 int __libc_sigaction(int sig, const struct sigaction *restrict sa, struct sigaction *restrict old)
 {
+    __libc_check_init();
 	struct k_sigaction ksa, ksa_old;
 	if (sa) {
 		if ((uintptr_t)sa->sa_handler > 1UL) {
diff --git a/src/stdio/__fdopen.c b/src/stdio/__fdopen.c
index 116e78e5..d84eeb50 100644
--- a/src/stdio/__fdopen.c
+++ b/src/stdio/__fdopen.c
@@ -11,6 +11,7 @@ FILE *__fdopen(int fd, const char *mode)
 	FILE *f;
 	struct winsize wsz;
 
+    __libc_check_init();
 	/* Check for valid initial mode character */
 	if (!strchr("rwa", *mode)) {
 		errno = EINVAL;
diff --git a/src/stdio/fmemopen.c b/src/stdio/fmemopen.c
index 343e3e3f..34993123 100644
--- a/src/stdio/fmemopen.c
+++ b/src/stdio/fmemopen.c
@@ -84,6 +84,7 @@ FILE *fmemopen(void *restrict buf, size_t size, const char *restrict mode)
 	struct mem_FILE *f;
 	int plus = !!strchr(mode, '+');
 	
+    __libc_check_init();
 	if (!strchr("rwa", *mode)) {
 		errno = EINVAL;
 		return 0;
diff --git a/src/stdio/open_memstream.c b/src/stdio/open_memstream.c
index 600d2770..d6fa408b 100644
--- a/src/stdio/open_memstream.c
+++ b/src/stdio/open_memstream.c
@@ -68,6 +68,7 @@ FILE *open_memstream(char **bufp, size_t *sizep)
 	struct ms_FILE *f;
 	char *buf;
 
+    __libc_check_init();
 	if (!(f=malloc(sizeof *f))) return 0;
 	if (!(buf=malloc(sizeof *buf))) {
 		free(f);
diff --git a/src/stdio/open_wmemstream.c b/src/stdio/open_wmemstream.c
index b8ae4a79..c917784d 100644
--- a/src/stdio/open_wmemstream.c
+++ b/src/stdio/open_wmemstream.c
@@ -74,6 +74,7 @@ FILE *open_wmemstream(wchar_t **bufp, size_t *sizep)
 	struct wms_FILE *f;
 	wchar_t *buf;
 
+    __libc_check_init();
 	if (!(f=malloc(sizeof *f))) return 0;
 	if (!(buf=malloc(sizeof *buf))) {
 		free(f);
diff --git a/src/thread/__lock.c b/src/thread/__lock.c
index 60eece49..ac849dc8 100644
--- a/src/thread/__lock.c
+++ b/src/thread/__lock.c
@@ -18,6 +18,7 @@
 
 void __lock(volatile int *l)
 {
+    __libc_check_init();
 	int need_locks = libc.need_locks;
 	if (!need_locks) return;
 	/* fast path: INT_MIN for the lock, +1 for the congestion */
diff --git a/src/thread/pthread_create.c b/src/thread/pthread_create.c
index 087f6206..4ca15d1b 100644
--- a/src/thread/pthread_create.c
+++ b/src/thread/pthread_create.c
@@ -246,6 +246,7 @@ int __pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict att
 	pthread_attr_t attr = { 0 };
 	sigset_t set;
 
+    __libc_check_init();
 	if (!libc.can_do_threads) return ENOSYS;
 	self = __pthread_self();
 	if (!libc.threaded) {
diff --git a/src/thread/pthread_getattr_np.c b/src/thread/pthread_getattr_np.c
index 2881831f..60360fcb 100644
--- a/src/thread/pthread_getattr_np.c
+++ b/src/thread/pthread_getattr_np.c
@@ -12,6 +12,7 @@ int pthread_getattr_np(pthread_t t, pthread_attr_t *a)
 		a->_a_stackaddr = (uintptr_t)t->stack;
 		a->_a_stacksize = t->stack_size;
 	} else {
+        __libc_check_init();
 		char *p = (void *)libc.auxv;
 		size_t l = PAGE_SIZE;
 		p += -(uintptr_t)p & PAGE_SIZE-1;
diff --git a/src/thread/synccall.c b/src/thread/synccall.c
index a6b177c0..3df10f7d 100644
--- a/src/thread/synccall.c
+++ b/src/thread/synccall.c
@@ -43,6 +43,7 @@ static void handler(int sig)
 
 void __synccall(void (*func)(void *), void *ctx)
 {
+    __libc_check_init();
 	sigset_t oldmask;
 	int cs, i, r;
 	struct sigaction sa = { .sa_flags = SA_RESTART | SA_ONSTACK, .sa_handler = handler };
diff --git a/src/time/__tz.c b/src/time/__tz.c
index c34b3eb7..336d26ff 100644
--- a/src/time/__tz.c
+++ b/src/time/__tz.c
@@ -172,6 +172,7 @@ static void do_tzset()
 	if (!posix_form) {
 		if (*s == ':') s++;
 		if (*s == '/' || *s == '.') {
+            __libc_check_init();
 			if (!libc.secure || !strcmp(s, "/etc/localtime"))
 				map = __map_file(s, &map_size);
 		} else {
